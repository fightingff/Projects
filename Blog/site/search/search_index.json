{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"Notebooks/ASM/","title":"x86\u6c47\u7f16\u8bed\u8a00\u57fa\u7840","text":""},{"location":"Notebooks/ASM/#_1","title":"\u57fa\u672c\u89c4\u5219","text":"<ul> <li> <p>\u5bc4\u5b58\u5668\uff1a</p> </li> <li> <p>ax  bx cx dx\uff08\u8ba1\u7b97\u5e38\u7528\uff09</p> </li> <li>ds cs(\u6307\u4ee4\u548c\u6570\u636e\u6bb5\u5730\u5740)\uff0css(\u5806\u6808\u5730\u5740)\uff0ces\uff08\u6bb5\u5bc4\u5b58\u5668)     \u6bb5\u5bc4\u5b58\u5668\u4e0d\u53ef\u4ee5\u76f4\u63a5\u8d4b\u503c\u5e38\u6570\u6216\u8ba1\u7b97\uff0c\u53ea\u80fd\u7528\u5bc4\u5b58\u5668\u6216\u53d8\u91cf\u8d4b\u503c</li> <li>si  di  bx  bp sp (\u504f\u79fb\u5730\u5740\u5bc4\u5b58\u5668\uff0c\u5373\u53ef\u4ee5\u653e\u8fdb[ ]\u4e2d)     \uff08\u5176\u4e2dss:sp\u6307\u5411\u6808\u9876\uff0cbp\u4e5f\u5e38\u7528\u4e8e\u6808\u4e2d\u5143\u7d20\uff09</li> <li>ip \uff08\u6307\u4ee4\u6307\u9488\uff0c\u6307\u4ee4\u7684\u504f\u79fb\u5730\u5740\uff09</li> <li>FL \uff0816\u4f4d\u8bb0\u5f55\u8fd0\u7b97\u72b6\u6001\uff09</li> <li>\u53cc\u76ee\u8fd0\u7b97\u4f4d\u5bbd\u76f8\u7b49\u4e14\u53ef\u786e\u5b9a\uff0c\u5e76\u4e14\u4e0d\u80fd\u540c\u65f6\u4e3a\u5185\u5b58\u5730\u5740   \u53d8\u91cf\u5f3a\u5236\u89c4\u5b9a\u4f4d\u5bbd\uff1a<code>byte/word/dword ptr</code></li> </ul> <p>\u5b9a\u4e49\u7684\u53d8\u91cf\u67d0\u79cd\u7a0b\u5ea6\u4e0a\u4e5f\u5c5e\u4e8e\u53ef\u786e\u5b9a\u5bbd\u5ea6\u7684\uff0c\u6240\u4ee5\u53ef\u4ee5\u76f4\u63a5 <code>mov a,0</code> - assume   \u672c\u8d28\u4e0a\u4e3a\u7701\u7565\u6bb5\u5730\u5740\u7684\u66ff\u6362</p> <p>(\u540c\u4e00\u4e2a\u6bb5\u4e0e\u591a\u4e2a\u6bb5\u5bc4\u5b58\u5668\u6709\u5173\u8054\u65f6:ds &gt; ss &gt; es &gt; cs)</p> <p>\u4f8b\u5982assume ds:data\u5373\u5c06data:\u81ea\u52a8\u66ff\u6362\u4e3ads:   \u6240\u4ee5\u4e00\u822c\u7a0b\u5e8f\u5f00\u5934\u6709</p> <p><code>asm   mov ax,data   mov ds,ax</code></p>"},{"location":"Notebooks/ASM/#_2","title":"\u6570\u636e\u5b58\u50a8","text":"<ul> <li>\u5185\u5b58\u4e2d\u5c0f\u7aef\u89c4\u5219\uff0c\u4f4e\u4f4d\u5728\u524d\uff0c\u9ad8\u4f4d\u5728\u540e</li> </ul> <p>\u5982    1234H  ---&gt;      34   12</p> <p>\u53ef\u7528\u4e0b\u9762\u4e24\u6bb5C\u8bed\u8a00\u4ee3\u7801\u9a8c\u8bc1</p> <pre><code>\n   unsigned short int a = 0x1234;\n   unsigned char *p;\n   p = (unsigned char *)&amp;a;\n   printf(\"%X %X\", p[0], p[1]);\n\n\n   unsigned char a[2]={0x12, 0x34};\n   unsigned short int *p;\n   p = (unsigned short int *)a;\n   printf(\"%X\", *p);\n\n</code></pre> <ul> <li>\u7b26\u53f7\u4e0d\u533a\u5206</li> </ul> <pre><code>a db 0FFh\n</code></pre> <p>\u5230\u5e95\u4ee3\u8868255\u8fd8\u662f-1,\u5728\u5b9a\u4e49\u65f6\u5e76\u4e0d\u786e\u5b9a</p> <p>\u4f46\u662f\u5728\u5f15\u7528\u53d8\u91cfa\u65f6\u53ef\u4ee5\u7528\u6307\u4ee4\u6765\u533a\u5206\u5b83\u662f\u975e\u7b26\u53f7\u8fd8\u662f\u6709\u7b26\u53f7</p> <p>\u4f8b\u5982 <code>imul  a</code>\u6307\u4ee4\u8868\u793a\u4e58\u4ee5  -1 \uff0c\u800c <code>mul a</code>\u6307\u4ee4\u5219\u8868\u793a\u4e58\u4ee5 255</p> <ul> <li>\u6bb5\u5730\u5740\uff1a\u504f\u79fb\u5730\u5740\uff08\u903b\u8f91\u5730\u5740\u5bfb\u5740\uff09   \u4ee55\u4f4d16\u8fdb\u5236\u7684\u5f62\u5f0f   XXXX:0000~~XXXX:FFFF   64KB   \u903b\u8f91\u5730\u5740XXXX0+YYYY   \u9700\u8981\u6ce8\u610f\u4e00\u4e2a\u7269\u7406\u5730\u5740\u53ef\u4ee5\u8868\u793a\u6210\u591a\u4e2a\u903b\u8f91\u5730\u5740</li> </ul> <p><code>12398h=1234:0058=1235:0048=1236:0038=1230:0098</code></p> <ul> <li> <p>\u5bfb\u5740\u65b9\u5f0f</p> </li> <li> <p>\u76f4\u63a5\u5bfb\u5740\uff08\u504f\u79fb\u5730\u5740\u4e3a\u5e38\u6570\uff0c\u6bb5\u5730\u5740\u5fc5\u987b\u4e3a\u6bb5\u5bc4\u5b58\u5668\uff09     1000H:[2000H]\u274c</p> </li> <li>\u95f4\u63a5\u5bfb\u5740\uff08\u504f\u79fb\u5730\u5740\u4e3a\u5bc4\u5b58\u5668+\u53d8\u91cf/\u6570\u7ec4\uff09</li> <li> <p>\u53d6\u5730\u5740\u8fd0\u7b97</p> </li> <li> <p>lea &amp; offset</p> <p>```asm \u8bbeabc\u7684\u504f\u79fb\u5730\u5740=1000h lea dx, abc         ; lea dx, [1000h] mov dx, offset abc  ; mov dx, 1000h</p> <p>mov dx, offset ds:[bx+si+3]   ; \u8bed\u6cd5\u9519\u8bef lea dx, ds:[bx+si+3]          ; dx=bx+si+3 mov dx, bx+si+3               ; \u9519\u8bef</p> <p>lea eax, [eax+eax4]          ; EAX=EAX5 \u7528lea\u505a\u4e58\u6cd5 ```   - lds &amp; les</p> <p>\u53d6\u8fdc\u6307\u9488\uff0c\u5e76\u5206\u522b\u628a\u6bb5\u5730\u5740\u8d4b\u7ed9ds/es\uff0c\u504f\u79fb\u5730\u5740\u8d4b\u7ed9\u76f8\u5e94\u76ee\u6807 - \u8fdc\u8fd1\u6307\u9488</p> </li> <li> <p>near ptr(\u504f\u79fb\u5730\u5740)</p> </li> <li> <p>far ptr   (\u6bb5\u5730\u5740:\u504f\u79fb\u5730\u5740)</p> <p>\u5047\u5b9a\u628a\u4e00\u4e2a\u8fdc\u6307\u94881234h:5678h\u5b58\u653e\u5230\u5730\u57401000:0000\u4e2d\uff0c\u5219\u5185\u5b58\u5e03\u5c40\u5982\u4e0b\uff1a  &amp;p=1000:0000 1000:0000 78h 1000:0001 56h 1000:0002 34h 1000:0003 12h</p> </li> </ul>"},{"location":"Notebooks/ASM/#_3","title":"\u7b97\u672f\u8fd0\u7b97","text":"<ul> <li><code>inc / dec  x</code>\u5355\u76ee\u8fd0\u7b97\uff08\u81ea\u52a0\u81ea\u51cf\uff0c\u4e0d\u5f71\u54cdCF\uff09</li> <li><code>add / sub  a,b</code>  \u53cc\u76ee\u8fd0\u7b97</li> <li><code>mul x</code> \u5355\u76ee\u8fd0\u7b97   \u6839\u636ex\u5bbd\u5ea6\u786e\u5b9a\u4e58\u6cd5\u5bbd\u5ea6</li> </ul> <p><code>asm   mul [1]     ah:al   = al * x   mul [2]     dx:ax   = ax * x   mul [4]     edx:eax = eax *x</code> - <code>div x</code> \u5355\u76ee\u8fd0\u7b97</p> <p>\u57fa\u672c\u53ef\u89c6\u4e3a\u4e58\u6cd5\u7684\u9006\u8fd0\u7b97\uff0c\u5176\u4e2ddx\u5b58\u4f59\u6570\uff0cax\u5b58\u5546</p> <p>\uff08\u6ce8\u610fdx\u7684\u6e05\u7a7a\uff0c\u5426\u5219\u6613\u51fa\u73b0divide overflow\u62a5\u9519\uff09</p> <p>32\u4f4d\u5341\u8fdb\u5236\u8f93\u51fa</p> <p><code>asm      mov di, 0; \u6570\u7ec4s\u7684\u4e0b\u6807      mov eax, abc      mov cx, 0; \u7edf\u8ba1push\u7684\u6b21\u6570   again:      mov edx, 0; \u88ab\u9664\u6570\u4e3aEDX:EAX      mov ebx, 10      div ebx; EAX=\u5546, EDX=\u4f59\u6570      add dl, '0'      push dx      inc cx; \u76f8\u5f53\u4e8eadd cx, 1      cmp eax, 0      jne again   pop_again:      pop dx      mov s[di], dl      inc di      dec cx; \u76f8\u5f53\u4e8esub cx, 1      jnz pop_again</code> - <code>&amp;     |     ^      ~      &lt;&lt;     &gt;&gt;   and   or    xor    not    shl    shr</code></p> <p>\u7b80\u5355\u4f4d\u8fd0\u7b97</p> <p>\uff08\u79fb\u4f4d\u8fd0\u7b97\u6700\u540e\u79fb\u51fa\u7684\u4e00\u4f4d\u5b58\u5230CF\u4e2d\uff09 - <code>rol       ror</code></p> <p>\u5faa\u73af\u79fb\u4f4d</p> <p><code>c   C\u8bed\u8a00   rol()  return x&lt;&lt;n | x&gt;&gt;(sizeof(x)*8-n)   ror()  return x&gt;&gt;n | x&lt;&lt;(sizeof(x)*8-n)</code></p> <p>\u7528\u8fd9\u4e9b\u6307\u4ee4\u6765\u5b8c\u6210\u5341\u516d\u8fdb\u5236\u8f93\u51fa\uff1a</p> <p><code>asm   again:      rol ax, 4  ;\u53d6\u51fa\u6700\u9ad84\u4f4d\u5230\u4f4e\u4f4d      push ax      and ax, 000Fh      cmp ax, 10      jb is_digit   is_alpha:      sub al, 10      add al, 'A'      jmp finish_4bits   is_digit:      add al, '0'   finish_4bits:      mov s[di], al      pop ax      pop cx      add di, 1      sub cx, 1      jnz again</code> - sal: shift arithmetic left  \u7b97\u672f\u5de6\u79fb   sar: shift arithmetic right \u7b97\u672f\u53f3\u79fb   sal\u53casar\u662f\u9488\u5bf9\u7b26\u53f7\u6570\u7684\u79fb\u4f4d\u8fd0\u7b97, \u5bf9\u8d1f\u6570\u53f3\u79fb\u7684\u65f6\u5019\u8981\u5728\u5de6\u8fb9\u88651, \u5bf9\u6b63\u6570\u53f3\u79fb\u7684\u65f6\u5019\u5de6\u8fb9\u88650, \u65e0\u8bba\u5bf9\u6b63\u6570\u8fd8\u662f\u8d1f\u6570\u5de6\u79fb\u53f3\u8fb9\u90fd\u88650</p>"},{"location":"Notebooks/ASM/#_4","title":"\u5806\u6808","text":"<ul> <li><code>push x</code></li> </ul> <p>16\u4f4d\u621632\u4f4d\uff0csp=sp-sizeof(x) - <code>pop x</code></p> <p>16\u4f4d\u621632\u4f4d\uff0csp=sp+sizeof(x) - <code>pushf &amp; popf</code> \u4fdd\u62a4FL\u72b6\u6001\u5bc4\u5b58\u5668 - \u624b\u52a8\u5b9a\u4e49\u5806\u6808\u7a7a\u95f4</p> <p><code>asm   stk segment stack   db 200h dup(0)    ;\u6216\u5199\u6210dw 100h dup(0)   stk ends</code></p>"},{"location":"Notebooks/ASM/#fl","title":"FL\u72b6\u6001\u5bc4\u5b58\u5668","text":"<p>CF ZF SF OF AF PF(\u72b6\u6001) DF TF IF\uff08\u63a7\u5236\uff09</p> <p>mov\u6307\u4ee4\u4e0d\u5f71\u54cd\u4efb\u4f55\u6807\u5fd7\u4f4d</p> <ul> <li>CF\uff08Carry Flag\uff09   \u52a0\u6cd5\u8fdb\u4f4d\uff0c\u51cf\u6cd5\u501f\u4f4d</li> </ul> <p><code>asm   jc  jnc  (jump if (not)carry flag)   adc      (add+CF)   sbb      (sub+CF)   clc CF=0   stc CF=1</code> - ZF(Zero Flag) - SF (Sign Flag   1 --&gt; - ) - OF (Overflow Flag) - PF\uff08Parity Flag\uff09</p> <p>\u5947\u5076\u6807\u5fd7\uff0c\u53ef\u505a\u6821\u9a8c\uff0c\u4f4e\u516b\u4f4d\u4e2d\u76841\u7684\u4e2a\u6570\uff0c1 --&gt; \u6709\u5076\u6570\u4e2a1 - AF(Auxiliary Flag)</p> <p>\u8f85\u52a9\u8fdb\u4f4d\u6807\u5fd7\uff0c1 --&gt; \u7b2c\u56db\u4f4d\u4e0e\u9ad8\u56db\u4f4d\u8fdb\u4f4d\u6216\u501f\u4f4d\u65f6 - DF(Direction Flag)   \u5b57\u7b26\u4e32\u590d\u5236\u65b9\u5411</p> <p><code>asm   cld DF=0 \u6b63\u65b9\u5411   std DF=1 \u53cd\u65b9\u5411</code> - IF(Interrupt Flag)   1 --&gt; \u5141\u8bb8\u4e2d\u65ad</p> <p><code>asm   cli   (\u7f6e0)   \u514d\u6253\u6270\u7a0b\u5e8f\u6bb5   sti  \uff08\u7f6e1\uff09</code> - TF(Trap Flag)   1 --&gt; \u8fdb\u5165\u5355\u6b65\u6a21\u5f0f\uff0c\u6bcf\u6761\u6307\u4ee4\u540e\u9690\u542bint 1H\uff08callback\uff09   \u7528\u4e8edebug\uff0c\u53cd\u8c03\u8bd5   \u88ab\u52a8\u9632\u5fa1\uff1a\u6821\u9a8c\u4ee3\u7801\u9632\u6b62\u66f4\u6539   \u4e3b\u52a8\u9632\u5fa1\uff1a\u62a2\u593a\u8d44\u6e90\uff0c\u81ea\u5df1\u83b7\u5f97int 1H\u4e3b\u52a8\u6743</p>"},{"location":"Notebooks/ASM/#_5","title":"\u5b57\u7b26\u4e32\u64cd\u4f5c","text":"<ul> <li>xlat(\u67e5\u8868)</li> </ul> <p>al=ds:[bx+al] - movsb movsw movsd(\u5bbd\u5ea6\u4e0d\u540c)</p> <p>\u2460ds:si   \u6e90\u5b57\u7b26\u4e32(si\u5c31\u662fsource index)   \u2461es:di  \u76ee\u6807\u5b57\u7b26\u4e32(di\u5c31\u662fdestination index)   \u2462cx      \u79fb\u52a8\u6b21\u6570   \u2463DF=0 \u5373\u65b9\u5411\u6807\u5fd7\u8bbe\u6210\u6b63\u65b9\u5411(\u7528\u6307\u4ee4cld) - stosb stosw stosd(\u5bbd\u5ea6\u4e0d\u540c)</p> <p>mov es:[di],     al/ax/eax</p>"},{"location":"Notebooks/ASM/#_6","title":"\u5173\u4e8e\u5faa\u73af","text":"<pre><code>loop label    ;while(--CX) jmp label\nloopz label   ;while(ZF &amp;&amp; --CX) jmp label\nloopnz label  ;while(!ZF &amp;&amp; --CX) jmp label\n</code></pre>"},{"location":"Notebooks/ASM/#_7","title":"\u5e38\u7528\u4e2d\u65ad","text":"<pre><code>\u7b49\u6548\u64cd\u4f5c\npushf, push cs, push ip\ntf = 0, if = 0\nip = word ptr 0:[n*4], cs = word ptr 0:[n*4+2]\n\nmov ah,01H\nint 21H           ;al=getchar()\n\nmov ah,02H\nint 21H           ;putchar(dl)\n\nmov ah,09H\nint 21H           ;cout &lt;&lt; ds:[dx]--&gt;'$'\n\nmov ah,0AH  \nint 21H           ;getline( ds:[dx+2] )\n          ;\u5176\u4e2dds:[dx]\u4e3a\u6700\u5927\u8bfb\u5165\u91cf\uff08\u8bb0\u5f97\u7f6e\u4e00\u4e2a\u5927\u6570\uff09\n          ;ds:[dx+1] \u4e3a\u5b9e\u9645\u8bfb\u5230\u7684\u5b57\u7b26\u6570 \n\nmov ah,4CH\nint 21H           ;exit\n\nmov ah,00H\nint 16H           ;AH = BIOS scan code\n                  ;AL = ASCII character\n\nmov ah,3DH\nint 21H           ;openfile\n\n;AL = access and sharing modes\n;DS:DX -&gt; ASCIZ filename\n;CL = attribute mask of files to look for\n\n;Return:\n;CF clear if successful\n;AX = file handle\n;CF set on error\n;AX = error code (01h,02h,03h,04h,05h,0Ch,56h)\n\n\n</code></pre>"},{"location":"Notebooks/ASM/#bcd","title":"\u5173\u4e8eBCD\u7801","text":"<p>\u4e00\u79cd\u7528\u5341\u516d\u8fdb\u5236\u8868\u793a\u5341\u8fdb\u5236\u6570\u7684\u65b9\u6cd5\uff0c\u6bd4\u5982\u7aef\u53e3\u4e2d\u65f6\u949f</p> <p>15H   <code>&lt;----&gt;</code>   15D</p> <ul> <li> <p>\u538b\u7f29BCD    4\u4f4d\u8868\u793a\u4e00\u4e2a\u5341\u8fdb\u5236\u4f4d</p> </li> <li> <p>daa  \u52a0\u6cd5\u8c03\u6574     \u5177\u4f53\u5730</p> </li> </ul> <p><code>cpp   if((AL &amp; 0FH) &gt;= 0AH) AL += 6H     //\u4f4e\u4f4d   if((AL &amp; 0F0H) &gt;= 0AH) AL += 60H   //\u9ad8\u4f4d</code>   - das \u51cf\u6cd5\u8c03\u6574\u7c7b\u4f3c - \u975e\u538b\u7f29BCD     8\u4f4d\u8868\u793a\u4e00\u4e2a\u5341\u8fdb\u5236\u4f4d</p> <p>8\u4e2a\u4e8c\u8fdb\u5236\u4f4d\u7684\u9ad8\u56db\u4f4d\u6ca1\u7528</p> <p>0306H  <code>&lt;----&gt;</code>  3366H  <code>&lt;----&gt;</code> 36D</p> <ul> <li>aaa  \u52a0\u6cd5\u8c03\u6574</li> <li>\u5177\u4f53\u5730</li> </ul> <p><code>cpp   if((AL &amp; 0FH) &gt;= 0AH) AL += 6 , AH++</code>   - aas \u51cf\u6cd5\u8c03\u6574\u7c7b\u4f3c   - aam \u4e58\u6cd5\u8c03\u6574</p> <pre><code>```cpp\nAH /= 10\nAL %= 10\n```\n</code></pre> <ul> <li> <p>aad \u9664\u6cd5 \u524d \u9884\u5148\u8c03\u6574</p> <p><code>cpp AL = (AH * 10 + AL) &amp; 0FFH AH = 0</code></p> </li> </ul>"},{"location":"Notebooks/DigitLogic/","title":"Logic and Computer Design Fundamentals","text":"<p>~~this review mainly focus on some special points and terminology~~</p>"},{"location":"Notebooks/DigitLogic/#some-special-codes","title":"Some Special Codes","text":"<ul> <li>BCD</li> </ul> <p>4 Binary bit as a Decimal bit Simply flatten up in converting</p> <ul> <li> <p>Excess 3 code</p> <ul> <li> <p>BCD + 3</p> </li> <li> <p>easy to do adding(automatically add carry)</p> </li> </ul> </li> <li> <p>Gray</p> </li> </ul> <p>Flip only one bit each turn \\(Gray Code = (K)_2 \\ \\ xor \\ \\ ((K)_2 &gt;&gt; 1)\\) Useful in K-map and optimization!</p> <ul> <li> <p>Parity Bit</p> </li> <li> <p>odd parity &amp; even parity</p> <ul> <li>Final result of 1's</li> </ul> </li> <li> <p>MSB &amp; LSB</p> <ul> <li>Most/Least Significant Bit</li> </ul> </li> <li> <p>Unsigned integer</p> </li> <li> <p>Radix Complement(\u8865\u7801)</p> <ul> <li>r\u2019s complement for radix r</li> <li>2\u2019s complement in binary</li> <li>Defined as \\(r^N - x\\)</li> <li>In Binary, as (~x + 1)</li> </ul> </li> <li> <p>Diminished Radix Complement\uff08\u53cd\u7801\uff09</p> <ul> <li>(r - 1)\u2019s complement for radix r</li> <li>1\u2019s complement for radix 2</li> <li>Defined as \\(r^N - 1 - x\\) , \"flipping\" every bit actually</li> </ul> </li> <li> <p>Signed integer</p> <ul> <li> <p>positive</p> <ul> <li>Both 1's and 2's complement are the same as true code</li> </ul> </li> <li> <p>negative</p> <ul> <li>1's complement is flipping every bit follow the sign bit</li> <li>2's complement is 1's complement + 1</li> </ul> </li> </ul> </li> </ul>"},{"location":"Notebooks/DigitLogic/#arithmetic-system","title":"Arithmetic System","text":"<ul> <li>In computer system, it's actually a \"\\(mod \\ r^N\\)\" system for N bit calculation</li> <li>\\(X - Y \\equiv X + r^N - Y \\equiv X + \\overline{Y}(mod \\ r^N)\\)</li> <li> <p>Unsigned Subtraction</p> <ul> <li>Use 2's Complement, then the answer actually is \\(X - Y + r^N\\)</li> <li>Thus check the final carry bit(actually Nth bit)<ul> <li>1 : \\(X \\geq Y\\), result is answer</li> <li>0 : \\(X &lt; Y\\), answer is negative, thus the answer is \\(-(r^N - result)\\)</li> </ul> </li> </ul> </li> <li> <p>Signed Subtraction</p> <ul> <li>Just use 2's Complement to convert subtraction into addition</li> </ul> </li> <li> <p>Overflow</p> <ul> <li> <p>Unsigned</p> <ul> <li>Extra carry bit in addition</li> </ul> </li> <li> <p>Signed</p> <ul> <li>(+A) + (+B) = (-C)</li> <li>(-A) + (-B) = (+C)</li> </ul> </li> </ul> </li> </ul>"},{"location":"Notebooks/DigitLogic/#boolean-algebra","title":"Boolean Algebra","text":"<ul> <li>Dual<ul> <li>Interchange only And/Or</li> </ul> </li> <li>Complement<ul> <li>DeMorgan's Law</li> </ul> </li> <li>Duality Rules</li> </ul> <p>A boolean equation remains valid if we take the dual of the expressions on both sides of the equals sign</p> <ul> <li> <p>Important Formulars</p> <ul> <li>\\(X + XY = X\\)</li> <li>\\(X(X+Y) = X\\)</li> <li>\\(XY + X \\overline{Y} = X\\)</li> <li>\\((X+Y)(X+\\overline{Y})=X\\)</li> <li>\\(X + \\overline{X}Y = X + Y\\)</li> <li>\\(X(\\overline{X}+Y)=XY\\)</li> <li>Consensus Theorem</li> </ul> </li> </ul> <p>\\(XY+\\overline{X}Z+YZ=XY+\\overline{X}Z\\)            (YZ is redundant) \\((X+Y)(\\overline{X}+Z)(Y+Z)=(X+Y)(\\overline{X}+Z)\\)        (dual)</p> <ul> <li>Canonical Form<ul> <li>SOM (sum of miniterm)<ul> <li>Choose 1's</li> </ul> </li> <li>POM (product of maxterm)<ul> <li>Choose 0's</li> </ul> </li> <li>SOP (sum of product)<ul> <li>Choose 1's</li> <li>Every product term contains all variables</li> </ul> </li> </ul> </li> <li>Cost<ul> <li>Literal cost<ul> <li>Number of literals</li> </ul> </li> <li>Gate-input cost<ul> <li>Input wires (literal cost + combinational structure)</li> </ul> </li> <li>Gate-input cost with NOTs<ul> <li>Gate-input cost + NOTs (count every literal only once)</li> </ul> </li> </ul> </li> <li>K-map<ul> <li>Implicant<ul> <li>A product term in SOP</li> </ul> </li> <li>Prime Implicant<ul> <li>A product term obtained by combining the maximum possible number of adjacent squares in the map with \\(2^N\\) number of squares</li> </ul> </li> <li>Essential Prime Implicant<ul> <li>Prime Implicant that essentially covers some squares(must pick)</li> </ul> </li> <li>Don't cares<ul> <li>Self assume the value, mostly choose 1</li> </ul> </li> <li>POS optimization<ul> <li>Optimize the \\(\\overline{F}\\) which is SOP</li> </ul> </li> </ul> </li> </ul>"},{"location":"Notebooks/DigitLogic/#combinational-logic","title":"Combinational Logic","text":"<ul> <li> <p>Delays</p> </li> <li> <p>Transition Time (Focus on output change)</p> <ul> <li>\\(t_{LH}=t_r\\) : 10% Low to 90% High  (rise)</li> <li>\\(t_{HL}=t_f\\) : 90% High to 10% Low  (fall)</li> </ul> </li> <li>Propagation Delay (Focus on output change by input change)<ul> <li>Time from half of input change to half of output change</li> <li>\\(t_{pd} = max(t_{pHL}, t_{pLH})\\)  (sometimes is average)</li> </ul> </li> <li>Model<ul> <li>Transport Delay<ul> <li>\\(t_{pd}=t_{\u56fa\u6709}+k*SL\\) (sum of fan-out standard loads)</li> </ul> </li> <li>Inertial Delay<ul> <li>Rejection Time : rejects narrow \u201cpulses\u201d on the outputs</li> </ul> </li> </ul> </li> <li> <p>Technology Mapping</p> <ul> <li>Use NAND/NOR to implement any logic</li> <li>Optimize<ul> <li>Push down NOTs</li> <li>Remove redundant gates (linked NOTs)</li> <li>Keep doing</li> </ul> </li> </ul> </li> <li> <p>Decoder</p> <ul> <li>\\(N - 2^N\\) One-Hot Decoder</li> <li>Hierarchical Design<ul> <li>\\(N-2^N = (\\frac{N}{2} - 2^{\\frac{N}{2}} )\\times (\\frac{N}{2} - 2^{\\frac{N}{2}})\\)</li> <li>Sometimes we can use ENABLE as a select signal</li> </ul> </li> </ul> </li> <li> <p>Encoder</p> <ul> <li>\\(2^N-N\\) One-Hot Encoder</li> <li>\\(2^K-N\\) Priority Encoder</li> </ul> </li> <li> <p>Multiplexer</p> <ul> <li>\\(2^N-1\\) MUX</li> <li>Input AND Decoder --OR--&gt; Output</li> <li>Expansion<ul> <li>Focus on how to cope with the multi-outputs of several MUXs</li> </ul> </li> <li>Implement Combinational Logic Function<ul> <li>Simple<ul> <li>Input: Output in truth table</li> <li>Select: Input</li> </ul> </li> <li>Efficient<ul> <li>Divide the input into two parts</li> <li>Select : the first part as the select signal of the second part</li> <li>Input : combination logic of the second part</li> </ul> </li> </ul> </li> <li>Use 3-state gate to optimize the cost</li> </ul> </li> <li> <p>Demultiplexer</p> <ul> <li>\\(1-2^N\\) DeMUX</li> </ul> </li> <li> <p>Half Adder  (No last carry)</p> <ul> <li>\\(S = A \\oplus B\\)</li> <li>\\(C = AB\\)</li> </ul> </li> <li> <p>Full Adder</p> <ul> <li>\\(S = (A \\oplus B)\\oplus Z\\)</li> <li>\\(C = AB + Z(A \\oplus B)\\)</li> </ul> </li> <li> <p>Ripple-Carry Binary Adder (*with \\(\\oplus\\) gate)</p> <ul> <li>Linked Full Adders</li> <li>The first carry 1 means doing subtraction(2's complement)</li> </ul> </li> <li> <p>*Carry Lookahead Adder</p> <ul> <li>\\(G_i = A_iB_i\\)</li> <li>\\(P_i = A_i \\oplus B_i\\)</li> <li>\\(C_{i+1} = G_i + P_iC_i\\)</li> <li>\\(S_i = P_i \\oplus C_i\\)</li> </ul> </li> <li> <p>(P)ROM</p> <ul> <li>Read-Only Memory</li> <li>Programmable only once</li> <li>\\(2^K \\times N\\) ROM (\\(2^K\\) addresses by \\(K - 2^K\\) Decoder, N bits per address)</li> <li>For a given address line, the connected data column is 1, others are 0</li> </ul> </li> <li> <p>PAL</p> <ul> <li>Programmable Array Logic</li> <li>Programmable only once</li> <li>K inputs into 2*K columns(\\(X/\\overline{X}\\))</li> <li>Fixed structure of N AO, but programmable AND terms</li> <li>One output can be used as input of another output as compensation</li> </ul> </li> <li> <p>PLA</p> <ul> <li>Programmable Logic Array</li> <li>Programmable only once</li> <li>K inputs into 2*K columns(\\(X/\\overline{X}\\))</li> <li>N programmable AND terms</li> <li>M programmable OR terms (select miniterms above) with M programmable XOR terms (get inverters)</li> <li>Optimize by optimizing both \\(F/\\overline{F}\\)</li> </ul> </li> <li> <p>FPGA</p> <ul> <li>Field Programmable Gate Array</li> <li>LUT</li> <li>Look-Up Table</li> <li>Like \\(2^K - 1\\) RAM</li> <li>Expansion:<ul> <li>Shannon\u2019s expansion theorem : \\(F = F(X_1, X_2, ..., X_n) = X_nF(X_1, X_2, ..., X_{n-1}, 1) + \\overline{X_n}F(X_1, X_2, ..., X_{n-1},0)\\)</li> </ul> </li> <li>*CLB<ul> <li>Configurable Logic Block</li> <li>LUT + Flip-Flop</li> </ul> </li> <li>*SM<ul> <li>Switch Matrix</li> <li>Interconnects between CLBs</li> </ul> </li> <li>*IOB<ul> <li>Input/Output Block</li> <li>Connects to the outside world</li> </ul> </li> </ul> </li> </ul>"},{"location":"Notebooks/DigitLogic/#sequential-logic","title":"Sequential Logic","text":"<ul> <li> <p>Synchonous &amp; Asynconous</p> <ul> <li>Synchonous : Triggered by discrete clock signal</li> <li>Asynconous : Triggered by input signal</li> </ul> </li> <li> <p>Buffer</p> <ul> <li>Store a bit, unable to change</li> <li>Delay = 2 * Inverter Delay</li> </ul> </li> <li> <p>Analysis</p> <ul> <li>Input Equation<ul> <li>\\(D_A = A(t)X(t)\\)</li> </ul> </li> <li>Output Equation<ul> <li>\\(Y(t)= F(A(t),X(t))\\)</li> </ul> </li> <li>Excitation Equation(D Flip-Flop)<ul> <li>\\(D_A = A(t+1)\\)</li> <li>Function of the current state and next state</li> </ul> </li> <li>Next State Equation(Characteristic equation)<ul> <li>\\(A(t+1) = D_A\\)</li> <li>A function of inputs and the current state</li> </ul> </li> </ul> </li> <li> <p>Latch</p> <ul> <li>Property<ul> <li>Store a bit, able to change and keep</li> <li>Too fast fallback and state change for a sequential circuit (transparent)</li> </ul> </li> <li>\\(S-R\\) Latch<ul> <li>NOR gates</li> <li>\\(R---Q\\) \\(S---\\overline{Q}\\)</li> <li>\\(S = 1, R = 0,Q = 1\\) : Set</li> <li>\\(S = 0, R = 1,Q = 0\\) : Reset</li> </ul> </li> <li>\\(\\overline{S}-\\overline{R}\\) Latch<ul> <li>NAND gates</li> <li>\\(\\overline{S}---Q\\) \\(\\overline{R}---\\overline{Q}\\)</li> <li>\\(S = 1(\\overline{S}=0), R = 0,Q=1\\) : Set</li> <li>\\(S = 0, R = 1,Q=0\\) : Reset</li> </ul> </li> <li>Clocked \\(S-R\\) Latch (\\(S-R\\) Latch with Control Input)<ul> <li>Add a control input to control the \\(\\overline{S}-\\overline{R}\\) latch</li> <li>\\(\\overline{S}\\) = S NAND C</li> </ul> </li> <li>Both Latches S=1,Q=1</li> <li>D Latch<ul> <li>Based on \\(\\overline{S}-\\overline{R}\\) Latch with Control Input</li> <li>Let \\(S = D, R = \\overline{D}\\) to avoid the forbidden state</li> <li>Q = D</li> </ul> </li> </ul> </li> <li> <p>Flip-Flop</p> <ul> <li> <p>Master - Slave FF</p> <ul> <li>Pulse - Triggered</li> <li>S-R MS FF<ul> <li>Master : Clocked S-R Latch</li> <li>Slave : Clocked S-R Latch</li> <li>Control Input : \\(C\\) &amp; \\(\\overline{C}\\)</li> <li>Every clock cycle only change once (half for master, half for slave)</li> <li>1's catching problem : glitch</li> </ul> </li> <li>J-K MS FF<ul> <li>Same as S-R MS FF, but with J-K Latch</li> <li>1 - 1 state permitted, flip to the opposite state</li> </ul> </li> <li>Edge - Triggered</li> <li>D MS FF<ul> <li>Master : D Latch</li> <li>Slave : Clocked S-R Latch</li> <li>Control Input : \\(C\\) &amp; \\(\\overline{C}\\)</li> <li>Since D Latch has no keeping state when clocked, no 1's catching problem</li> <li>Positive/Negative - level triggered flip-flop : associated with the output slave</li> <li>*Direct inputs : often for initial set</li> </ul> </li> <li>T Flip-Flop<ul> <li>J-K MS FF with J = K</li> <li>\\(T = 1\\) : Toggle</li> <li>\\(T = 0\\) : Keep</li> <li>*Edge-Triggered D Flip-Flop</li> </ul> </li> </ul> </li> <li> <p>Timing parameters</p> <ul> <li>Setup Time \\(t_s\\)<ul> <li>Time before clock edge that data must be stable</li> <li>*For Edge-trigger it's short, for Pulse-trigger it keep for whole pulse</li> </ul> </li> <li>Hold Time \\(t_h\\)<ul> <li>Time after clock edge that data must be stable</li> </ul> </li> <li>Propagation Delay \\(t_{pd}\\)<ul> <li>Time from input change to output change</li> </ul> </li> <li>\\(t_h\\) in \\(t_{pd}\\) and often \\(t_h &lt; t_{pd}\\), thus often ignore \\(t_h\\) in analysis</li> <li>Clock cycle time &gt; longest propagation delay from one clock edge to another edge</li> </ul> </li> </ul> </li> </ul>"},{"location":"Notebooks/DigitLogic/#hardware-implementation","title":"Hardware Implementation","text":"<ul> <li> <p>*CMOS</p> <ul> <li>NMOS - GND, PMOS - VCC</li> <li>NMOS &amp; PMOS in series(complesmentary &amp; dual)</li> </ul> </li> <li> <p>Register</p> </li> </ul> <p>A set of flip-flops, possibly with added combinational gates, that perform data-processing tasks. The flip-flops hold data, and the gates determine the new or transformed data to be transferred into the flip-flops</p> <ul> <li> <p>Structure</p> <ul> <li>Clock<ul> <li>Sequential control</li> </ul> </li> <li>Flip-Flops<ul> <li>Storage</li> </ul> </li> <li>Data Path (micro-operation)<ul> <li>Processing data</li> <li>Transfer data</li> </ul> </li> <li>Control Unit<ul> <li>Control the data path</li> </ul> </li> </ul> </li> <li> <p>Load</p> <ul> <li>Parallel Load</li> </ul> <p>Load all bits at the same time (clock cycle) </p> <ul> <li>Clock gating<ul> <li>\\(C = \\overline{Load} + Clock\\)</li> <li>Clock skew problem, hard to implement</li> </ul> </li> <li>Load enable<ul> <li>\\(D = Load \\cdot D + \\overline{Load} \\cdot Q\\)</li> <li>Actually a MUX</li> </ul> </li> <li>Serial Load</li> </ul> <p>Load one bit at a time (clock cycle) </p> <ul> <li>Useful in data transmission</li> </ul> </li> <li> <p>Transfer</p> <p>Condition: DR[...] &lt;- SR[Address] </p> <ul> <li>Multiplexer and Bus -Based Transfers</li> <li>For single register (too expensive)<ul> <li>\\(Load = K_1 + K_2 + ... +K_n\\)</li> <li>\\(D = MUX(Input,K)\\)</li> </ul> </li> <li>For multiple registers<ul> <li>Bus : a set of multiplexer outputs shared as a common path (single source problem)</li> <li>Three-state gates : bidirectional input\u2013output lines</li> </ul> </li> </ul> </li> <li> <p>Processing</p> <ul> <li>ALU<ul> <li>Arithmetic micro-operations</li> <li>Logic micro-operations</li> </ul> </li> <li> <p>Shift micro-operations</p> <ul> <li> <p>Serial shift</p> <ul> <li>Serial link the flip-flops</li> <li>With a proper clock difference, SO can get the serial result</li> <li>For N bits:<ul> <li>Starts with N - K clcok cycles, get SI &lt;&lt; K</li> <li>Start with N + K clock cycles, get SI &gt;&gt; K</li> </ul> </li> </ul> </li> <li> <p>Parallel shift</p> <ul> <li>Parallel output</li> <li>Just add an output for each flip-flop</li> <li>Parallel load</li> <li>Use combinational logic to control the load (MUX)</li> <li>\\(Shift:Q \\leftarrow shift (Q)\\) \\(\\overline{Shift} \\cdot Load: Q \\leftarrow D\\) \\(\\overline{Shift} \\cdot \\overline{Load}: Q \\leftarrow Q\\)</li> </ul> </li> <li> <p>Bidirectional shift</p> <ul> <li>Add a control signal to control the direction of shift</li> <li>\\(\\overline{S_1} S_0: D \\leftarrow SL(Q)\\) \\(S_1 \\overline{S_0}: D \\leftarrow SR(Q)\\) \\(S_1 S_0: D \\leftarrow Input\\) \\(\\overline{S_1} \\overline{S_0}: D \\leftarrow Q\\)</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Counter</p> <ul> <li> <p>Ripple counter</p> <ul> <li>\\(C_{i+1} = \\overline{Q_i}(add)/Q_i(dec)\\) \\(D_i = \\overline{Q_i}\\)</li> <li>Consider every time Q flips, the next flip-flop will be triggered</li> </ul> </li> <li> <p>Serial counter</p> <ul> <li>Same clock</li> <li>Control the D input of each flip-flop, but D relies on the previous flip-flop</li> </ul> </li> <li> <p>Parallel counter</p> <ul> <li>Update all in a single clock cycle</li> <li>More efficient than serial counter</li> </ul> </li> <li> <p>Other counter</p> <ul> <li>Modulo-N counter</li> <li>BCD counter</li> </ul> </li> </ul> </li> <li> <p>Memory</p> </li> <li> <p>Some terminology</p> <ul> <li>Word<ul> <li>A groups of bits that are accessed together</li> </ul> </li> <li>Width (Memory width)<ul> <li>The number of bits in a word</li> </ul> </li> <li>Depth (Address width)<ul> <li>The number of words in a memory</li> </ul> </li> <li>Memory size = Width * Depth</li> <li>Memory data path width<ul> <li>The number of bits that can be transferred in a bus</li> </ul> </li> <li>Latency time<ul> <li>From application of row address until first word available</li> </ul> </li> <li>Burst size<ul> <li>The number of words/bits transferred in a burst</li> </ul> </li> <li>Memory bandwidth<ul> <li>Speed of data transfer</li> <li>Bandwidth = Burst size / (Latency time + Burst Size * Cycle time)   (Busrt size plus 2 if it's DDR)</li> </ul> </li> </ul> </li> <li> <p>Read / Write</p> <ul> <li>CS (Chip Select)<ul> <li>Enable the memory</li> </ul> </li> <li>Address line<ul> <li>Select the word</li> </ul> </li> <li>Data line<ul> <li>Read / Write the data</li> </ul> </li> <li>Access time<ul> <li>Time from address to output data</li> </ul> </li> <li>Write cycle time<ul> <li>Time between successive writes</li> </ul> </li> </ul> </li> <li> <p>Special Technicals</p> <ul> <li>bidirectional pins for data line<ul> <li>Use three-state gates</li> </ul> </li> <li>Coincidence selection<ul> <li>2D array : Access by row address and column address</li> <li>Often the address line is used for both row select and column select, not row line and column line</li> </ul> </li> </ul> </li> <li> <p>Extension</p> <ul> <li>Word extension<ul> <li>Just parallel the data line</li> </ul> </li> <li>Depth extension<ul> <li>Use a decoder with CS to choose the memory</li> </ul> </li> </ul> </li> <li> <p>SRAM</p> <p>Static Random Access Memory </p> <ul> <li>Structure<ul> <li>Storage on S-R Latch</li> <li>Dual input &amp; output</li> </ul> </li> <li>Volatile</li> <li>Expensive</li> </ul> </li> <li> <p>DRAM</p> <p>Dynamic Random Access Memory </p> <ul> <li>Structure<ul> <li>Storage on capacitor</li> <li>Single input &amp; output</li> </ul> </li> <li>Cheap</li> <li>Dense</li> <li>Read / Write<ul> <li>Row address \\(\\rightarrow\\) Column address \\(\\rightarrow\\) \\(\\rightarrow\\) I/O activated \\(\\rightarrow\\) Data valid \\(\\rightarrow\\) Refresh</li> </ul> </li> <li> <p>Refresh</p> <ul> <li>Recharge the capacitor</li> <li>Control by \\(\\overline{RAS}\\) &amp; \\(\\overline{CAS}\\) of outside devices (0 triggered)</li> <li>Methods<ul> <li>RAS-only refresh<ul> <li>Refresh the whole row</li> <li>The row address is controlled by IC</li> <li>\\(RAS =0,CAS =1\\)</li> </ul> </li> <li>CAS-before-RAS refresh<ul> <li>Controlled by inner counter</li> <li>\\(CAS =0 \\rightarrow RAS = 0\\)</li> </ul> </li> <li>Hidden refresh<ul> <li>CAS-before-RAS refresh following a normal read / write</li> </ul> </li> </ul> </li> <li>Mode<ul> <li>Burst mode<ul> <li>stop the work and refresh all memory for a while</li> </ul> </li> <li>Distributed refresh<ul> <li>Refresh the memory in a distributed way</li> <li>space out refresh one row at a time, thus avoid blocking memory for a long time</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>SDRAM</p> </li> </ul> <p>Synchronous DRAM </p> <ul> <li>Burst length<ul> <li>Number of words accessed in a single access (burst read)</li> </ul> </li> </ul> </li> <li> <p>DDR SDRAM</p> <p>Double Data Rate SDRAM </p> <ul> <li>Transfer data on both rising and falling edges of the clock</li> </ul> </li> <li> <p>*RDRAM</p> <p>Rambus DRAM </p> </li> </ul>"},{"location":"Notebooks/DigitLogic/#labs","title":"Labs","text":"<ul> <li> <p>74LS138</p> <ul> <li>3-8 decoder</li> <li>3 inputs, 8 outputs (negative one-hot logic)</li> <li>3 enable inputs \\(G,\\overline{G2A},\\overline{G2B}\\)</li> </ul> </li> <li> <p>MC14495</p> <ul> <li>4 bit Hex - 7 segment decoder</li> <li>negative logic</li> <li>a - f clockwise, g in the middle, p is point</li> </ul> </li> </ul>"},{"location":"Notebooks/DigitLogic/#verilog","title":"Verilog","text":"<ul> <li> <p>\u95e8\u7ea7</p> <ul> <li>or,and,not,nand,nor,xor,xnor(output,input1,input2) </li> </ul> </li> <li> <p>RTL</p> <ul> <li>assign  </li> </ul> </li> <li> <p>\u884c\u4e3a\u7ea7</p> <ul> <li>always @(*) </li> </ul> </li> </ul>"}]}